# 나의 풀이
def solution(N, M):
    """
    Args:
        N: maximum of range
        M: target number
    """
    
    # sieve of eratosthenes
    is_prime = [True for _ in range(N)]
    
    for i in range(2, int(N**0.5)):
        if is_prime[i]:
            for j in range(2*i, N, i):
                is_prime[j] = False
    
    primes = [n for n, p in enumerate(is_prime) if p and n >= 2]
    
    # calculate subtotals
    sum_of_primes = [0] * (len(primes) + 1)
    for i in range(len(primes)):
        sum_of_primes[i+1] = sum_of_primes[i] + primes[i]
    
    # two pointer
    count = 0
    start = 0
    end = 1
    
    while start < len(sum_of_primes) and primes[end-1] <= M:
        if sum_of_primes[end] - sum_of_primes[start] == M:
            count += 1
            start += 1
        elif sum_of_primes[end] - sum_of_primes[start] > M:
            start += 1
        else:
            if end < len(sum_of_primes) - 1:
                end += 1
            else:
                start += 1
    
    return count
    
# 회고
- 먼저 에라토스테네스의 체 알고리즘을 사용하여 N 이하의 소수들을 모두 구한다.
- 다음으로 첫번째 소수부터 i번째 소수까지의 모든 연속된 부분합을 구한다.
- 마지막으로 투포인터를 이용해서 시작점과 끝점을 관리하며 두 부분합의 차가 M인 경우의 수를 모두 구한다.
